### 列表
#### 定义
> 序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。
Python有6个序列的内置类型，但最常见的是列表和元组。
序列都可以进行的操作包括索引，切片，加，乘，检查成员。
此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法

>在Python中，用方括号表示一个列表——[ ]。
>在方括号里面，可以是数字（整数、浮点数），也可以是字符串，甚至也能够是True/False这种布尔值。
>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示：
>```python
>list1 = ['Google', 'Runoob', 1997, 2000];
>list2 = [1, 2, 3, 4, 5 ];
>list3 = ["a", "b", "c", "d"];
>```
>与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。

#### 索引切片
>使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符
>```python
>list1 = ['Google', 'Runoob', 1997, 2000];
>list2 = [1, 2, 3, 4, 5, 6, 7 ];
>
>print ("list1[0]: ", list1[0])
>print ("list2[1:5]: ", list2[1:5])
>```



#### 反转
>反转并不是在原地进行操作，而是生成了新的值
>反转的方法
>```python
>#对列表进行反转
>In [101]: alst = [1,2,3,4,5,6]
>
>In [102]: alst[::-1]
>Out[102]: [6, 5, 4, 3, 2, 1]
>#对字符串进行反转
>In [103]: lang = 'python'
>
>In [104]: lang[::-1]
>Out[104]: 'nohtyp'
>#对原来的值并没有产生影响
>In [105]: alst
>Out[105]: [1, 2, 3, 4, 5, 6]
>
>In [106]: lang
>Out[106]: 'python'
>
>In [107]: id(alst)
>Out[107]: 139648463800776
>
>In [108]: id(lang)
>Out[108]: 139648608062408
>#产生了新的对象
>In [109]: id(alst[::-1])
>Out[109]: 139648463222792
>
>In [110]: id(lang[::-1])
>Out[110]: 139648462032152
>```

#### 嵌套
>```python
>In [111]: [1,2,3,[1,2,3]]
>```


#### 操作列表
>##### 基本操作
>>######`len()`
>>######`+`,`*`
>>######`cmp()`
>>######`in`,`not in`
>>######`max()`,`min()`



#### 列表内置函数
>|序号	|方法|
>|-----|----|
>|1	|list.append(obj)<br>在列表末尾添加新的对象|
>|2	|list.count(obj)<br>统计某个元素在列表中出现的次数 |
>|3	|list.extend(seq)<br>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）|
>|4	|list.index(obj)<br>从列表中找出某个值第一个匹配项的索引位置|
>|5	|list.insert(index, obj)<br>将对象插入列表
>|6	|list.pop(obj=list[-1])<br>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值|
>|7	|list.remove(obj)<br>移除列表中某个值的第一个匹配项|
>|8	|list.reverse()<br>反向列表中元素
>|9	|list.sort([func])<br>对原列表进行排序
>|10 |	list.clear()<br>清空列表|
>|11	|list.copy()<br>复制列表



#### 列表推导式
> 列表推导式也即列表生成式，是Python内置的一个非常强大的生成列表的方式
> 格式
> `[expr for iter_var in iterale]`
> 迭代`iterable`中的所有内容，每一次迭代，生成的内容放入到`iter_var`中，在用表达式应用该`iter_var`的内容，最后用表达式生成一个列表。
>用一道题目来演示它的用法
>```python
>#!/usr/bin/env python
># coding=utf-8
>b = [23,45,22,44,25,66,78]
>#1.生成所有奇数组成的列表
>t1 = [i for i in b if i % 2 == 1]
>print(t1)
># t1=[23, 45, 25]
>#分解式子
>b1 = []
>for i in b:
>    if i % 2 == 1:
>        b1.append(i)
>print(b1)
>#2.输出结果 ['the content 23','the content 45']
>list2 = [i for i in b if i % 2 == 1]
>list2.remove(25)
>['the content %d' % i for i in list2 ]
>#3.a = [1,2,3,4,5,6,7],输出结果包含元祖的列表
>a = [1,2,3,4,5,6,7]
>[(i,j) for i in b for j in a]
>#分解式子
>t1 = []
>for i in b:
>    for j in a:
>       t1.append((i,j))
>
>print(t1)
>
#### 字典的推导式
>`dict1 = {(i,j) for i in a for j in b}``

>```python
>{(1, 22),
> (1, 23),
> (1, 25),
> (1, 44),
> (1, 45),
> (1, 66),
> (1, 78),
> (2, 22),
> (2, 23),
> (2, 25),
> (2, 44),
> (2, 45),
> (2, 66),
> (2, 78),
> (3, 22),
> (3, 23),
> (3, 25),
> (3, 44),
> (3, 45),
> (3, 66),
> (3, 78),
> (4, 22),
> (4, 23),
> (4, 25),
> (4, 44),
> (4, 45),
> (4, 66),
> (4, 78),
> (5, 22),
> (5, 23),
> (5, 25),
> (5, 44),
> (5, 45),
> (5, 66),
> (5, 78),
> (6, 22),
> (6, 23),
> (6, 25),
> (6, 44),
> (6, 45),
> (6, 66),
> (6, 78),
> (7, 22),
> (7, 23),
> (7, 25),
> (7, 44),
> (7, 45),
> (7, 66),
> (7, 78)}
>#因为 dict 可以直接作用与元祖进行创建
>```
